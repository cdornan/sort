
module Data.Sort
  (
  -- * Vanilla Sort
    L.sort
  , L.sortBy
  , sortON
  -- * Sorting Associations
  , monoidSortAssocs
  , monoidSortAssocsBy
  , groupSortAssocs
  , groupSortAssocsBy
  -- * Sorting with Monoids
  , monoidSort
  , monoidSortOn
  , monoidSortBy
  -- * Group Sorting
  , groupSort
  , groupSortOn
  , groupSortBy
  ) where

import qualified Data.List                as L
import           Data.Monoid
import           Data.Ord


-- | Sort the list using the ordering on the values generated by the
-- argument function; this function replicates the recently introduced
-- @Data.List.sortOn@ function in @base@ so that it can be used in
-- older versions of @base@.
sortON :: Ord b => (a->b) -> [a] -> [a]
sortON chg = project . L.sortBy cmp_key . inject chg

-- | Sort the list of associations, aggregating duplicates with the
-- monoid.
monoidSortAssocs :: (Monoid a,Ord k)
                 => [(k,a)]
                 -> [(k,a)]
monoidSortAssocs = monoidSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- monoid and ordering the keys with the argument compare function.
monoidSortAssocsBy :: (Monoid a)
                   => (k->k->Ordering)
                   -> [(k,a)]
                   -> [(k,a)]
monoidSortAssocsBy cmp = groupSortAssocsBy cmp $ const monoid_group

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function.
groupSortAssocs :: Ord k
                => (k->a->[a]->b)
                -> [(k,a)]
                -> [(k,b)]
groupSortAssocs = groupSortAssocsBy compare

-- | Sort the list of associations, aggregating duplicates with the
-- supplied function and ordering the keys with the argument
-- compare function.
groupSortAssocsBy :: (k->k->Ordering)
                  -> (k->a->[a]->b)
                  -> [(k,a)]
                  -> [(k,b)]
groupSortAssocsBy cmp0 grp0 = groupSortBy cmp grp
  where
    cmp (k,_) (k',_) = cmp0 k k'

    grp (k,y) ps     = (,) k $ grp0 k y $ map snd ps


-- | Sort the list, agregating duplicates with the monoid.
monoidSort :: (Monoid a,Ord a) => [a] -> [a]
monoidSort = monoidSortBy compare

-- | Sort the list, agregating duplicates with the monoid and
-- ordering the elements by the items generated by the
-- argument function.
monoidSortOn :: (Monoid a,Ord k) => (a->k) -> [a] -> [a]
monoidSortOn chg = groupSortOn chg $ const monoid_group

-- | Sort the list, agregating duplicates with the monoid
-- and ordering the keys with the argument compare function.
monoidSortBy :: Monoid a => (a->a->Ordering) -> [a] -> [a]
monoidSortBy cmp = groupSortBy cmp monoid_group



-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function
groupSort :: (Ord a) => (a->[a]->b) -> [a] -> [b]
groupSort = groupSortBy compare

-- | Sort a list of elements with a stable sort, using the argument
-- @compare@ function determine the ordering, grouping together the
-- equal elements with the grouping function
groupSortOn :: Ord k
            => (a->k)
            -> (k->a->[a]->b)
            -> [a]
            -> [b]
groupSortOn chg grp =
    project . groupSortBy cmp_key grp_val . inject chg
  where
    grp_val a as = Assoc k $ grp k (_a_value a) $ map _a_value as
      where
        k = _a_key a

-- | Sort a list of elements with a stable sort, grouping together the
-- equal elements with the argument grouping function.
groupSortBy :: (a->a->Ordering)
            -> (a->[a]->b)
            -> [a]
            -> [b]
groupSortBy cmp grp = aggregate . L.sortBy cmp
  where
    aggregate []    = []
    aggregate (h:t) = seq g $ g : aggregate rst
      where
        g         = grp h eqs
        (eqs,rst) = span is_le t

        is_le x   = case cmp x h of
          LT -> True
          EQ -> True
          GT -> False


-- the Assoc helpers

data Assoc k a =
  Assoc
    { _a_key   :: !k
    , _a_value :: a
    }
  deriving (Show)

inject :: (a->k) -> [a] -> [Assoc k a]
inject chg = map $ \x -> Assoc (chg x) x

project :: [Assoc k a] -> [a]
project = map _a_value

cmp_key :: Ord k => Assoc k a -> Assoc k a -> Ordering
cmp_key = comparing _a_key


-- the monoid_group helper

monoid_group :: Monoid a => a -> [a] -> a
monoid_group x xs = x <> mconcat xs
